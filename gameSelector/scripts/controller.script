local data = require "main.data"

function init(self)
    print("Game Selector Controller: Initializing...")
    msg.post(".", "acquire_input_focus")
    
    -- Game data with information about each available minigame
    self.games = {
        {
            id = "bubbles",
            title = "Bubble Pop",
            collection = "/gameBubbles/gameBubbles.collection",
            color = vmath.vector4(0.3, 0.7, 1.0, 1.0), -- Light blue
            description = "Pop floating bubbles in the ocean!"
        },
        {
            id = "bubblewrap", 
            title = "Bubble Wrap",
            collection = "/gameBubbleWrap/gameBubbleWrap.collection",
            color = vmath.vector4(1.0, 0.4, 0.6, 1.0), -- Pink
            description = "Pop all the bubbles in the grid!"
        },
        {
            id = "xylophone",
            title = "Xylophone",
            collection = "/gameXylophone/gameXylophone.collection", 
            color = vmath.vector4(0.9, 0.7, 0.2, 1.0), -- Gold
            description = "Make beautiful music!"
        }
    }
    
    -- GUI state
    self.scroll_position = 0
    self.max_scroll = 0
    self.scroll_velocity = 0
    self.is_dragging = false
    self.drag_start_x = 0
    self.drag_start_scroll = 0
    self.current_game = nil
    
    -- Calculate scroll parameters
    self.button_width = 300
    self.button_spacing = 40
    self.total_width = #self.games * (self.button_width + self.button_spacing) - self.button_spacing
    self.visible_width = data.SW - 100  -- Screen width minus margins
    self.max_scroll = math.max(0, self.total_width - self.visible_width)
    
    print("Game Selector initialized with " .. #self.games .. " games")
    print("Max scroll distance: " .. self.max_scroll)
    
    -- Enable GUI rendering
    msg.post("@render:", "use_camera_projection")
    msg.post("gameSelector#gameSelector", "enable")
end

function final(self)
    msg.post(".", "release_input_focus")
end

function update(self, dt)
    local prev_scroll = self.scroll_position
    
    -- Apply scroll physics
    if not self.is_dragging then
        -- Apply momentum and bouncing
        if self.scroll_velocity ~= 0 then
            self.scroll_position = self.scroll_position + self.scroll_velocity * dt
            
            -- Bounce at edges with elastic effect
            local bounce_strength = 800
            local damping = 0.92
            
            if self.scroll_position < 0 then
                -- Left bounce
                self.scroll_velocity = self.scroll_velocity + (-self.scroll_position) * bounce_strength * dt
                if self.scroll_position < -50 then
                    self.scroll_position = -50
                end
            elseif self.scroll_position > self.max_scroll then
                -- Right bounce  
                self.scroll_velocity = self.scroll_velocity - (self.scroll_position - self.max_scroll) * bounce_strength * dt
                if self.scroll_position > self.max_scroll + 50 then
                    self.scroll_position = self.max_scroll + 50
                end
            end
            
            -- Apply damping
            self.scroll_velocity = self.scroll_velocity * damping
            
            -- Stop very small velocities
            if math.abs(self.scroll_velocity) < 10 then
                self.scroll_velocity = 0
                -- Snap back to bounds
                if self.scroll_position < 0 then
                    self.scroll_position = 0
                elseif self.scroll_position > self.max_scroll then
                    self.scroll_position = self.max_scroll
                end
            end
        end
    end
    
    -- Update GUI if scroll position changed
    if math.abs(self.scroll_position - prev_scroll) > 0.1 then
        msg.post("gameSelector#gameSelector", "update_scroll", {
            scroll_position = self.scroll_position
        })
    end
end

function on_message(self, message_id, message, sender)
    print("Controller: Received message: " .. tostring(message_id) .. " from: " .. tostring(sender))
    if message_id == hash("launch_game") then
        print("Controller: Received launch_game message for game: " .. tostring(message.game_id))
        print("Controller: Available games in controller:")
        for i, game in ipairs(self.games) do
            print("  Game " .. i .. ": " .. game.id .. " = " .. game.title)
        end
        launchGame(self, message.game_id)
    elseif message_id == hash("proxy_loaded") then
        -- Collection proxy has loaded successfully
        print("âœ… Game collection loaded successfully")
        print("Controller: Enabling loaded game collection")
        -- Use the appropriate proxy based on the current game
        local proxy_name = nil
        if self.current_game == "bubbles" then
            proxy_name = "gameProxyBubbles"
        elseif self.current_game == "bubblewrap" then
            proxy_name = "gameProxyWrap"
        elseif self.current_game == "xylophone" then
            proxy_name = "gameProxyXylophone"
        end
        if proxy_name then
            msg.post(proxy_name .. "#" .. proxy_name, "enable")
            -- Give the loaded game a moment to acquire input focus
            timer.delay(0.1, false, function()
                print("Controller: Input focus should now be with the loaded game")
            end)
        end
        -- The loaded game should now acquire its own input focus
        print("Controller: Game collection enabled, input should now go to loaded game")
    elseif message_id == hash("proxy_unloaded") then
        -- Collection proxy has unloaded
        print("ðŸ”„ Game collection unloaded")
        -- Re-enable the game selector GUI
        msg.post("gameSelector#gameSelector", "enable")
        -- Re-acquire input focus for the game selector
        msg.post(".", "acquire_input_focus")
        self.current_game = nil
        print("Controller: Returned to game selector, input focus restored")
    elseif message_id == hash("return_to_selector") then
        -- Return to game selector from a game
        returnToSelector(self)
    else
        print("Controller: Unknown message received: " .. tostring(message_id))
    end
end

function on_input(self, action_id, action)
    -- Handle back button / escape key to return to selector
    if action_id == hash("key_esc") or action_id == hash("key_backspace") then
        if action.pressed and self.current_game then
            returnToSelector(self)
            return true  -- Consume the input
        end
    end

    -- When a game is loaded, don't consume any input - let it pass through to the game
    if self.current_game then
        return false
    end

    -- Handle touch/mouse input for scrolling (only when no game is loaded)
    if action_id == hash("touch") then
        if action.pressed then
            print("Controller: Touch pressed at " .. action.screen_x .. ", " .. action.screen_y)
            self.is_dragging = false  -- Reset dragging state
            self.drag_start_x = action.screen_x
            self.drag_start_scroll = self.scroll_position
            self.drag_threshold = 10  -- Minimum distance to consider as drag
            self.scroll_velocity = 0
            -- Don't consume the input - let GUI also handle it
            return false
        elseif action.released then
            -- Check if this was a drag or a tap
            local drag_distance = math.abs(action.screen_x - self.drag_start_x)
            if drag_distance > self.drag_threshold then
                -- This was a drag, not a tap
                self.is_dragging = false
                -- Calculate final velocity based on drag distance and time
                -- This creates momentum scrolling
                self.scroll_velocity = -drag_distance * 4  -- Negative because we scroll opposite to drag
                print("Controller: Drag released, distance: " .. drag_distance)
            else
                -- This was a tap, not a drag
                print("Controller: Tap detected, distance: " .. drag_distance)
            end
            -- Don't consume the input - let GUI also handle it
            return false
        else
            -- Dragging
            local drag_distance = action.screen_x - self.drag_start_x
            if math.abs(drag_distance) > self.drag_threshold then
                self.is_dragging = true
                self.scroll_position = self.drag_start_scroll - drag_distance

                -- Immediately update GUI during dragging for smooth visual feedback
                msg.post("gameSelector#gameSelector", "update_scroll", {
                    scroll_position = self.scroll_position
                })
            end
            -- Don't consume the input - let GUI also handle it
            return false
        end
    end

    -- GUI will handle button clicks and send messages back to us
    return false
end

function launchGame(self, game_id)
    print("=== CONTROLLER DEBUG ===")
    print("Controller: launchGame called with game_id: " .. tostring(game_id))
    print("Controller: Current games in memory:")
    for i, game in ipairs(self.games) do
        print("  [" .. i .. "] id='" .. game.id .. "' title='" .. game.title .. "' collection='" .. game.collection .. "'")
    end
    
    -- Find the game data
    local selected_game = nil
    for _, game in ipairs(self.games) do
        print("Controller: Comparing '" .. tostring(game_id) .. "' with '" .. game.id .. "'")
        if game.id == game_id then
            selected_game = game
            print("Controller: MATCH FOUND! Selected game: " .. game.title)
            break
        end
    end
    
    if not selected_game then
        print("Controller: ERROR - No game found with id: " .. tostring(game_id))
        return
    end

    if selected_game then
        print("ðŸš€ Launching " .. selected_game.title .. "...")

        -- Unload current game if any
        if self.current_game then
            print("Controller: Unloading current game: " .. self.current_game)
            -- Use the appropriate proxy based on the current game
            local proxy_name = nil
            if self.current_game == "bubbles" then
                proxy_name = "gameProxyBubbles"
            elseif self.current_game == "bubblewrap" then
                proxy_name = "gameProxyWrap"
            elseif self.current_game == "xylophone" then
                proxy_name = "gameProxyXylophone"
            end
            if proxy_name then
                msg.post(proxy_name .. "#" .. proxy_name, "unload")
            end
            self.current_game = nil
        end

        -- Load the selected game collection using multiple proxies
        if selected_game.collection then
            print("Controller: Loading collection: " .. selected_game.collection)
            -- Set the current game BEFORE loading to prevent race conditions
            self.current_game = game_id
            
            -- Use the appropriate proxy based on the game
            local proxy_name = nil
            if game_id == "bubbles" then
                proxy_name = "gameProxyBubbles"
            elseif game_id == "bubblewrap" then
                proxy_name = "gameProxyWrap"
            elseif game_id == "xylophone" then
                proxy_name = "gameProxyXylophone"
            else
                print("Controller: ERROR - Unknown game ID: " .. game_id)
                return
            end
            
            print("Controller: Using proxy: " .. proxy_name)
            
            -- Disable the game selector GUI first
            msg.post("gameSelector#gameSelector", "disable")
            
            -- Release input focus so the loaded game can handle input
            print("Controller: Releasing input focus for loaded game")
            msg.post(".", "release_input_focus")
            
            -- Load the collection using the appropriate proxy
            print("Controller: Loading collection via proxy: " .. proxy_name)
            msg.post(proxy_name .. "#" .. proxy_name, "load")

            print("âœ… Loading " .. selected_game.title)
            print("Controller: Using dedicated proxy for: " .. game_id)
        end
    else
        print("ERROR: Game not found: " .. game_id)
    end
end

function returnToSelector(self)
    print("ðŸ”™ Returning to game selector...")
    
    -- Unload current game if any
    if self.current_game then
        -- Use the appropriate proxy based on the current game
        local proxy_name = nil
        if self.current_game == "bubbles" then
            proxy_name = "gameProxyBubbles"
        elseif self.current_game == "bubblewrap" then
            proxy_name = "gameProxyWrap"
        elseif self.current_game == "xylophone" then
            proxy_name = "gameProxyXylophone"
        else
            print("Controller: ERROR - Unknown current game: " .. tostring(self.current_game))
            return
        end
        
        print("Controller: Unloading game via proxy: " .. proxy_name)
        msg.post(proxy_name .. "#" .. proxy_name, "unload")
        -- The proxy_unloaded message will re-enable the GUI
    else
        -- No game loaded, just enable the GUI
        print("Controller: No game loaded, enabling GUI")
        msg.post("gameSelector#gameSelector", "enable")
    end
end

function on_reload(self)
    -- Hot reload support
end
