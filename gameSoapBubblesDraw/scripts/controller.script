math.randomseed(os.time())

local data = require "main.data"

function init(self)
	print("SoapBubblesDraw game: Initializing...")
	-- Don't acquire input focus - input comes from main script
	
	rendercam = require "rendercam.rendercam"
	lastTouchPos = vmath.vector3()
	
	-- Store active touches for multitouch support
	self.activeTouches = {}
	
	-- Drawing state
	self.isDrawing = false
	self.lastDrawPos = nil
	self.drawPath = {}
	
	-- Bubble creation parameters
	self.bubbleSpawnTimer = 0
	self.bubbleSpawnInterval = 0.03 -- Create bubble every 0.03 seconds while drawing
	
	print("SoapBubblesDraw game: Initialization complete!")
end

function final(self)
	msg.post(".", "release_input_focus")
end

function update(self, dt)
	-- Update bubble spawn timer only while actively drawing AND moving
	if self.isDrawing and #self.drawPath > 1 then -- Only spawn during movement, not single clicks
		self.bubbleSpawnTimer = self.bubbleSpawnTimer + dt
		if self.bubbleSpawnTimer >= self.bubbleSpawnInterval then
			self.bubbleSpawnTimer = 0
			spawn_bubble_at_path(self)
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("return_to_selector") then
		print("SoapBubblesDraw game: Returning to selector")
		msg.post("main:/go#main", "return_to_selector")
	elseif message_id == hash("input") then
		-- Only log on press/release to reduce spam
		if message.action.pressed or message.action.released then
			print("SoapBubblesDraw: Received forwarded input")
		end
		handle_input(self, message.action_id, message.action)
	elseif message_id == hash("bubble_popped") then
		-- A bubble was successfully popped
		lastTouchPos = message.position
		msg.post("/particleSpawner#particleSpawner", "POP")
		sound.play("/soundfx#pop", {speed = math.random(70, 100) / 100})
	end
end

function handle_input(self, action_id, action)
	-- Handle escape key to return to selector
	if action_id == hash("key_esc") and action.pressed then
		msg.post(".", "return_to_selector")
		return true
	end
	
	-- Handle touch input for drawing only (no bubble popping)
	if action_id == hash("touch") or action_id == hash("multitouch") then
		if action.pressed and action.screen_x and action.screen_y then
			-- Start drawing
			local worldPos = rendercam.screen_to_world_2d(action.screen_x, action.screen_y)
			if worldPos then
				-- Create initial bubble on tap/click immediately
				spawn_bubble_at_position(self, worldPos)
				
				-- Set up drawing state for continuous drawing
				self.isDrawing = true
				self.lastDrawPos = worldPos
				self.drawPath = {worldPos}
				self.bubbleSpawnTimer = 0 -- Reset timer for continuous drawing
				
				-- Store touch for tracking
				local touch_id = action.touch_id or 1
				self.activeTouches[touch_id] = {x = action.x, y = action.y}
			end
		elseif action.released then
			-- Stop drawing
			self.isDrawing = false
			self.drawPath = {}
			
			-- Remove touch tracking
			local touch_id = action.touch_id or 1
			self.activeTouches[touch_id] = nil
		elseif self.isDrawing and action.screen_x and action.screen_y then
			-- Continue drawing path
			local worldPos = rendercam.screen_to_world_2d(action.screen_x, action.screen_y)
			if worldPos and self.lastDrawPos then
				-- Only add to path if moved enough distance
				local dist = vmath.length(worldPos - self.lastDrawPos)
				if dist > 20 then -- Minimum distance between path points
					table.insert(self.drawPath, worldPos)
					self.lastDrawPos = worldPos
				end
			end
		end
	end
	
	return true
end



function spawn_bubble_at_position(self, position)
	-- Add some randomness to the position
	local offsetX = math.random(-15, 15)
	local offsetY = math.random(-15, 15)
	local spawnPos = position + vmath.vector3(offsetX, offsetY, 0)
	
	-- Create bubble via spawner
	msg.post("/spawner#spawner", "spawn_bubble", {position = spawnPos})
end

function spawn_bubble_at_path(self)
	if #self.drawPath > 0 then
		-- Get a random position from the current draw path
		local pathIndex = math.random(1, #self.drawPath)
		local spawnPos = self.drawPath[pathIndex]
		
		spawn_bubble_at_position(self, spawnPos)
	end
end

-- No more bubble deletion function - bubbles auto-pop