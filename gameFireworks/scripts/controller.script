-- Fireworks Game Controller
-- Handles input and triggers firework explosions

math.randomseed(os.time())

local data = require "main.data"

function init(self)
    print("Fireworks game: Initializing...")
    msg.post(".", "acquire_input_focus")
    print("Fireworks game: Input focus acquired!")
    
    -- Initialize rendercam for coordinate conversion
    rendercam = require "rendercam.rendercam"
    
    -- Track active touches for multitouch support
    self.activeTouches = {}
    
    -- Track active fireworks for performance management
    self.activeFireworks = {}
    self.maxFireworks = 10
    
    -- Firework creation cooldown to prevent spam
    self.lastFireworkTime = 0
    self.fireworkCooldown = 0.1  -- 100ms between fireworks
    
    print("Fireworks game: Initialization complete!")
end

function final(self)
    msg.post(".", "release_input_focus")
    
    -- Clean up any remaining fireworks
    for i, firework_id in ipairs(self.activeFireworks) do
        if go.exists(firework_id) then
            go.delete(firework_id)
        end
    end
end

function update(self, dt)
    -- Update cooldown timer
    if self.lastFireworkTime > 0 then
        self.lastFireworkTime = self.lastFireworkTime - dt
        if self.lastFireworkTime < 0 then
            self.lastFireworkTime = 0
        end
    end
end

function on_message(self, message_id, message, sender)
    if message_id == hash("return_to_selector") then
        print("Fireworks game: Returning to selector")
        msg.post("main:/go#main", "return_to_selector")
    elseif message_id == hash("input") then
        print("Fireworks: Received forwarded input")
        handle_input(self, message.action_id, message.action)
    elseif message_id == hash("firework_created") then
        -- Track new firework for cleanup
        table.insert(self.activeFireworks, message.firework_id)
        print("Fireworks: Tracking firework " .. tostring(message.firework_id))
    elseif message_id == hash("firework_completed") then
        -- Remove completed firework from tracking
        for i, firework_id in ipairs(self.activeFireworks) do
            if firework_id == message.firework_id then
                table.remove(self.activeFireworks, i)
                print("Fireworks: Removed completed firework " .. tostring(message.firework_id))
                break
            end
        end
    end
end

function handle_input(self, action_id, action)
    -- Handle escape key to return to selector
    if action_id == hash("key_esc") and action.pressed then
        msg.post(".", "return_to_selector")
        return true
    end
    
    -- Handle touch input for fireworks
    if action_id == hash("touch") or action_id == hash("multitouch") then
        if action.pressed then
            print("Fireworks: Touch at " .. (action.screen_x or 0) .. ", " .. (action.screen_y or 0))
            
            -- Store touch for multitouch tracking
            local touch_id = action.touch_id or 1
            self.activeTouches[touch_id] = {x = action.x, y = action.y, screen_x = action.screen_x, screen_y = action.screen_y}
            
            -- Create firework at touch location
            if action.screen_x and action.screen_y then
                create_firework(self, action)
            end
        elseif action.released then
            -- Remove touch when released
            local touch_id = action.touch_id or 1
            self.activeTouches[touch_id] = nil
        end
    end
    
    return true
end

function on_input(self, action_id, action)
    return handle_input(self, action_id, action)
end

function create_firework(self, action)
    -- Check cooldown to prevent spam
    if self.lastFireworkTime > 0 then
        return
    end
    
    -- Check if we've reached the maximum number of active fireworks
    if #self.activeFireworks >= self.maxFireworks then
        print("Fireworks: Maximum fireworks reached, skipping")
        return
    end
    
    -- Validate screen coordinates
    if not action.screen_x or not action.screen_y then
        print("Fireworks: Invalid screen coordinates")
        return
    end
    
    -- Convert screen position to world position
    local worldPos = rendercam.screen_to_world_2d(action.screen_x, action.screen_y)
    
    if not worldPos then
        print("Fireworks: Failed to convert screen to world coordinates")
        return
    end
    
    print("Fireworks: Creating firework at world position " .. worldPos.x .. ", " .. worldPos.y)
    
    -- Set cooldown
    self.lastFireworkTime = self.fireworkCooldown
    
    -- Send message to fireworks spawner with position and properties
    msg.post("/fireworksSpawner#fireworksSpawner", "spawn_firework", {
        position = worldPos,
        screen_position = vmath.vector3(action.screen_x, action.screen_y, 0)
    })
    
    -- Play sound effect immediately for responsive feedback
    sound.play("/soundfx#firework", {
        speed = math.random(80, 120) / 100  -- Pitch variation
    })
end

function cleanup_old_fireworks(self)
    -- Remove any fireworks that no longer exist
    local active_count = 0
    for i = #self.activeFireworks, 1, -1 do
        local firework_id = self.activeFireworks[i]
        if not go.exists(firework_id) then
            table.remove(self.activeFireworks, i)
        else
            active_count = active_count + 1
        end
    end
    
    print("Fireworks: Active fireworks count: " .. active_count)
end