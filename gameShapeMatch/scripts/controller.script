local data = require "main.data"

function init(self)
	msg.post(".", "acquire_input_focus")
	
	rendercam = require "rendercam.rendercam"
	
	-- Store active touches for multitouch support
	self.activeTouches = {}
	
	-- Initialize shape matching game
	msg.post("/shapeGameManager#shapeGameManager", "init_game")
	
	print("Shape Matching game initialized!")
end

function final(self)
	msg.post(".", "release_input_focus")
end

function update(self, dt)
	-- Game loop - could add background animations or effects here
end

function on_message(self, message_id, message, sender)
	if message_id == hash("window_resized") then
		print('window resized to ' .. message.width .. ' x ' .. message.height)
		-- Reinitialize game on window resize
		msg.post("/shapeGameManager#shapeGameManager", "init_game")
	elseif message_id == hash("game_ready") then
		-- Game is ready, could show UI or play intro sound
		print("Shape matching game ready - let the matching begin!")
	elseif message_id == hash("level_complete") then
		-- All shapes have been matched! Celebrate!
		print("ðŸŽ† Congratulations! All shapes matched! New level coming soon...")
		-- Play celebration sound
		sound.play("/soundfx#success", {speed = 1.2, gain = 0.8})
	end
end

function on_input(self, action_id, action)
	-- Handle multitouch properly
	if action_id == hash("touch") or action_id == hash("multitouch") then
		if action.pressed then
			-- Store touch ID for tracking (use 1 for mouse if touch_id is not available)
			local touch_id = action.touch_id or 1
			self.activeTouches[touch_id] = {x = action.x, y = action.y}
		elseif action.released then
			-- Remove touch ID when released
			local touch_id = action.touch_id or 1
			self.activeTouches[touch_id] = nil
		end
	end
	
	-- Handle shape interaction on press, release, and drag for better responsiveness
	-- Only call handleInput if we have valid screen coordinates
	if action.screen_x and action.screen_y and (action.pressed or action.released) then
		handleShapeInput(self, action)
	elseif action.screen_x and action.screen_y and not action.pressed and not action.released then
		-- Handle drag updates
		handleShapeInput(self, action)
	end
end

function handleShapeInput(self, inputAction)
	-- Make sure we have valid input action
	if not inputAction then
		print("WARNING: handleShapeInput called with nil inputAction")
		return
	end
	
	-- Make sure we have valid screen coordinates
	if not inputAction.screen_x or not inputAction.screen_y then
		print("WARNING: handleShapeInput called without screen coordinates")
		return
	end
	
	-- Convert screen position to world position
	local worldPos = rendercam.screen_to_world_2d(inputAction.screen_x, inputAction.screen_y)
	
	-- Make sure we got a valid world position
	if not worldPos then
		return
	end
	
	-- Send input event to shape game manager with world coordinates
	local inputType = "unknown"
	if inputAction.pressed then
		inputType = "pressed"
	elseif inputAction.released then
		inputType = "released"
	else
		inputType = "drag"  -- Continuous drag movement
	end
	
	msg.post("/shapeGameManager#shapeGameManager", "shape_input", {
		world_pos = worldPos,
		input_type = inputType,
		touch_id = inputAction.touch_id or 1
	})
end

function on_reload(self)
	-- Hot reload support
end
