math.randomseed(os.time())

local data = require "main.data"

function init(self)
	print("Bubbles game: Initializing...")
	print("Bubbles game: About to acquire input focus...")
	msg.post(".", "acquire_input_focus")
	print("Bubbles game: Input focus acquired!")
	print("Bubbles game: Initialization complete!")

	rendercam = require "rendercam.rendercam"
	
	lastTouchPos = vmath.vector3()

	-- Store active touches for multitouch support
	self.activeTouches = {}
	
	-- Remove unused variables
	-- wx, wy = window.get_size()
	
	particlefx.play('/groundBubbles')
	particlefx.play('/sunRays')
end

function final(self)
	msg.post(".", "release_input_focus")
end

function update(self, dt)

end

function on_message(self, message_id, message, sender)
	if message_id == hash("window_resized") then
		print('window resized to ' .. message.width .. ' x ' .. message.height)
	elseif message_id == hash("bubbles_list") then
		-- Store the bubbles list for use in deleteBubble function
		self.current_bubbles = message.bubbles
	elseif message_id == hash("return_to_selector") then
		-- Return to game selector
		print("Bubbles game: Returning to selector")
		msg.post("main:/go#main", "return_to_selector")
	elseif message_id == hash("input") then
		-- Handle forwarded input from main
		print("Bubbles: Received forwarded input")
		handle_input(self, message.action_id, message.action)
	end
end

function handle_input(self, action_id, action)
	print("Bubbles: Handling input: " .. tostring(action_id))
	
	-- Handle escape key to return to selector
	if action_id == hash("key_esc") and action.pressed then
		msg.post(".", "return_to_selector")
		return true
	end
	
	-- Handle multitouch properly
	if action_id == hash("touch") or action_id == hash("multitouch") then
		if action.pressed then
			print("Bubbles: Touch at " .. (action.screen_x or 0) .. ", " .. (action.screen_y or 0))
			-- Store touch ID for tracking (use 1 for mouse if touch_id is not available)
			local touch_id = action.touch_id or 1
			self.activeTouches[touch_id] = {x = action.x, y = action.y}
		elseif action.released then
			-- Remove touch ID when released (use 1 for mouse if touch_id is not available)
			local touch_id = action.touch_id or 1
			self.activeTouches[touch_id] = nil
		end
	end
	
	-- Delete bubbles on both press and release for better responsiveness
	-- Only call deleteBubble if we have valid screen coordinates
	if action.screen_x and action.screen_y then
		deleteBubble(self, action)
	end
end

function on_input(self, action_id, action)
	return handle_input(self, action_id, action)
end

function on_reload(self)
	
end

function deleteBubble(self, tapPos)
	-- Make sure we have valid screen coordinates
	if not tapPos.screen_x or not tapPos.screen_y then
		return
	end
	
	-- Convert screen position to world position once, outside the loop
	local worldPos = rendercam.screen_to_world_2d(tapPos.screen_x, tapPos.screen_y)
	
	-- Make sure we got a valid world position
	if not worldPos then
		return
	end
	
	-- More efficient bubble iteration using the spawner's bubble list
	local spawner = "/spawner#spawner"
	
	-- Get bubbles list from spawner
	local bubbles_list = nil
	if self.current_bubbles then
		bubbles_list = self.current_bubbles
	else
		-- Fallback to global bubbles if not received yet
		bubbles_list = bubbles or {}
	end
	
	-- Iterate through bubbles more efficiently using ipairs instead of the custom tablelength function
	local bubbleCount = #bubbles_list
	for i = 1, bubbleCount do
		local bubble_id = bubbles_list[i]
		if bubble_id then
			local bbPos = go.get_position(bubble_id)
			-- Make sure we got a valid position
			if bbPos then
				local dist = worldPos - bbPos

				-- Use squared distance to avoid sqrt calculation
				local dist_squared = dist.x * dist.x + dist.y * dist.y
				if dist_squared < 60 * 60 then  -- 60 pixels radius
					-- Remove from spawner's list more efficiently
					msg.post(spawner, "remove_bubble", {id = bubble_id})
					-- Don't remove from local table here, let spawner handle it
					go.delete(bubble_id)

					lastTouchPos = bbPos
					msg.post("/particleSpawner#particleSpawner", "POP")

					sound.play("/soundfx#pop", {speed = math.random(70, 100) / 100})
					break
				end
			end
		end
	end
end




