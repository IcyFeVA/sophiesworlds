local data = require "main.data"

function init(self)
	print("Bubble Wrap game: Initializing...")
	msg.post(".", "acquire_input_focus")
	print("Bubble Wrap game: Input focus acquired!")
	
	rendercam = require "rendercam.rendercam"
	
	-- Store active touches for multitouch support
	self.activeTouches = {}
	
	-- Initialize bubble grid
	msg.post("/bubbleGridSpawner#bubbleGridSpawner", "init_grid")
	
	print("Bubble Wrap game initialized!")
end

function final(self)
	msg.post(".", "release_input_focus")
end

function update(self, dt)
	-- Game loop - could add background animations or effects here
end

function on_message(self, message_id, message, sender)
	if message_id == hash("window_resized") then
		print('window resized to ' .. message.width .. ' x ' .. message.height)
		-- Reinitialize grid on window resize
		msg.post("/bubbleGridSpawner#bubbleGridSpawner", "init_grid")
	elseif message_id == hash("bubble_grid_ready") then
		-- Grid is ready, could show UI or play intro sound
		print("Bubble grid ready - let the popping begin!")
	elseif message_id == hash("grid_complete") then
		-- All bubbles have been popped! Could add screen flash or other celebration
		print("ðŸŽ† Congratulations! All bubbles popped! New ones coming soon...")
		-- Could add visual effects here like screen flash or particle burst
	elseif message_id == hash("return_to_selector") then
		-- Return to game selector
		print("Bubble Wrap game: Returning to selector")
		msg.post("main:/go#main", "return_to_selector")
	elseif message_id == hash("input") then
		-- Handle forwarded input from main
		print("Bubble Wrap: Received forwarded input")
		handle_input(self, message.action_id, message.action)
	end
end

function handle_input(self, action_id, action)
	print("Bubble Wrap: Handling input: " .. tostring(action_id))
	
	-- Handle escape key to return to selector
	if action_id == hash("key_esc") and action.pressed then
		msg.post(".", "return_to_selector")
		return true
	end
	
	-- Handle multitouch properly
	if action_id == hash("touch") or action_id == hash("multitouch") then
		if action.pressed then
			print("Bubble Wrap: Touch at " .. (action.screen_x or 0) .. ", " .. (action.screen_y or 0))
			-- Store touch ID for tracking (use 1 for mouse if touch_id is not available)
			local touch_id = action.touch_id or 1
			self.activeTouches[touch_id] = {x = action.x, y = action.y}
		elseif action.released then
			-- Remove touch ID when released
			local touch_id = action.touch_id or 1
			self.activeTouches[touch_id] = nil
		end
	end
	
	-- Pop bubbles on both press and release for better responsiveness
	-- Only call popBubble if we have valid screen coordinates
	if action.screen_x and action.screen_y and (action.pressed or action.released) then
		popBubble(self, action)
	end
end

function on_input(self, action_id, action)
	return handle_input(self, action_id, action)
end

function popBubble(self, tapPos)
	-- Make sure we have valid input action
	if not tapPos then
		print("WARNING: popBubble called with nil tapPos")
		return
	end
	
	-- Make sure we have valid screen coordinates
	if not tapPos.screen_x or not tapPos.screen_y then
		print("WARNING: popBubble called without screen coordinates")
		return
	end
	
	-- Convert screen position to world position
	local worldPos = rendercam.screen_to_world_2d(tapPos.screen_x, tapPos.screen_y)
	
	-- Make sure we got a valid world position
	if not worldPos then
		return
	end
	
	-- Send pop request to grid spawner with world coordinates
	msg.post("/bubbleGridSpawner#bubbleGridSpawner", "try_pop_bubble", {
		world_pos = worldPos
	})
end

function on_reload(self)
	-- Hot reload support
end
